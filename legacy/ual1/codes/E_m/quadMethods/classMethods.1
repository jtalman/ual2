// quad file
quad()
  : UAL::PropagatorNode()
{
//initialize();
  init();
  m_ir = 0.0;
}

quad(const E_m::quad& mt) 
  : UAL::PropagatorNode(mt)
{
  copy(mt);
}

~quad()
{
}

quad* clone()
{
  return new quad(*this);
}

void setLatticeElements(const UAL::AcceleratorNode& sequence, 
                                            int is0, 
                                            int is1,
                                            const UAL::AttributeSet& attSet)
{
// ETEAPOT::BasicTracker::setLatticeElements(sequence, is0, is1, attSet);
   const PacLattice& lattice     = (PacLattice&) sequence;
   setLatticeElement(lattice[is0]);
}

void setLatticeElement(const PacLattElement& e)
{
  // length
  // m_l = e.getLength();

  // ir
  m_ir = e.getN();

if(!m_ir){
// std::cerr << "enter quad::void setLatticeElement(const PacLattElement& e) - m_ir = e.getN()- " << m_ir << "\n";
}
else{
 std::cerr << "Complex Elements not allowed!!!\n";
 exit(1);
}

  m_mdata.setLatticeElement(e);

}

void init(){
  m_ir=0;
  m_ir = 0.0;
}

void copy(const E_m::quad& mt) 
{
  // m_l   = mt.m_l;
  m_ir  = mt.m_ir;

  m_mdata = mt.m_mdata;
}

const char*  getType(){
  return "JDT:::E_m::quad";
}

bool isSequence() { return false; }

UAL::AcceleratorNode& getFrontAcceleratorNode()
{
//return m_frontNode;
}

UAL::AcceleratorNode& getBackAcceleratorNode()
{
//return m_backNode;
}
