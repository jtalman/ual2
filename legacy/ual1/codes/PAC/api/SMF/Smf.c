/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.18 from the
 * contents of Smf.xs. Do not edit this file, edit Smf.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Smf.xs"
#include <assert.h> 

#ifdef __cplusplus
extern "C" {
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#ifdef __cplusplus
}
#endif

#ifdef do_open
#undef do_open
#endif

#ifdef do_close
#undef do_close
#endif

#ifdef list
#undef list
#endif


#include <string>
#include "SMF/PacSmf.h"

using namespace ZLIB;

#line 41 "Smf.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 183 "Smf.c"

XS_EUPXS(XS_Pac__Smf_create); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__Smf_create)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	PacSmf *	RETVAL;
#line 37 "Smf.xs"
        char* CLASS = "Pac::Smf";
        RETVAL = new PacSmf();
#line 196 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__Smf_initialize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__Smf_initialize)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "smf");
    {
	PacSmf*	smf;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		smf = (PacSmf *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::Smf::initialize() -- smf is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 47 "Smf.xs"
        string tmpStr;
        char   tmpChr1[80];
        char   tmpChr2[80];
        char   tmpChrN[80];

        int max_order = 10;

        PacElemKeyIterator eki;
        for(eki = smf->elemKeys()->begin(); eki != smf->elemKeys()->end(); eki++){
           tmpStr = (*eki).name();
           /* tmpStr.upcase(); */
           strncpy(tmpChr1, tmpStr.c_str(), tmpStr.length());
           tmpChr1[tmpStr.length()] = '\0';
           sprintf(tmpChr2, "main::%s", tmpChr1);
           sv_setref_pv(perl_get_sv(tmpChr2, TRUE), 
			"Pac::ElemKey", 
			(void*) new PacElemKey(*eki));
        }

	PacElemBucketKeyIterator bki;
	for(bki = smf->bucketKeys()->begin(); bki != smf->bucketKeys()->end(); bki++){
	   for(int aki = 0; aki < (*bki).size(); aki++){
	      tmpStr = (*bki)[aki].name();
              /* tmpStr.upcase(); */
	      strncpy(tmpChr1, tmpStr.c_str(), tmpStr.length()); 
              tmpChr1[tmpStr.length()] = '\0'; 
              sprintf(tmpChr2, "main::%s", tmpChr1);         
	      sv_setref_pv(perl_get_sv(tmpChr2, TRUE), 
			"Pac::ElemAttribKey", 
			(void*) new PacElemAttribKey((*bki)[aki]));
	      if((*bki).order())
                for(int order = 0; order < max_order; order++){
	           sprintf(tmpChrN, "main::%s%d", tmpChr1, order);
	           sv_setref_pv(perl_get_sv(tmpChrN, TRUE), 
				"Pac::ElemAttribKey", 
				(void*) new PacElemAttribKey((*bki)[aki](order)));  
                } 
           } 
        } 
#line 260 "Smf.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Pac__Smf_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__Smf_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacSmf *	THIS;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacSmf *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::Smf::DESTROY() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	delete THIS;
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Pac__Smf_elemKeys); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__Smf_elemKeys)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacSmf *	THIS;
	PacElemKeys *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacSmf *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::Smf::elemKeys() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 94 "Smf.xs"
	char* CLASS = "Pac::ElemKeys";
	RETVAL = THIS->elemKeys();
#line 309 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__Smf_bucketKeys); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__Smf_bucketKeys)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacSmf *	THIS;
	PacElemBucketKeys *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacSmf *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::Smf::bucketKeys() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 102 "Smf.xs"
	char* CLASS = "Pac::ElemBucketKeys";
	RETVAL = THIS->bucketKeys();
#line 337 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__Smf_elements); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__Smf_elements)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacSmf *	THIS;
	PacGenElements *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacSmf *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::Smf::elements() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 110 "Smf.xs"
	char* CLASS = "Pac::GenElements";
	RETVAL = THIS->elements();
#line 365 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__Smf_lines); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__Smf_lines)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacSmf *	THIS;
	PacLines *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacSmf *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::Smf::lines() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 118 "Smf.xs"
	char* CLASS = "Pac::Lines";
	RETVAL =  THIS->lines();
#line 393 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__Smf_lattices); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__Smf_lattices)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacSmf *	THIS;
	PacLattices *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacSmf *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::Smf::lattices() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 126 "Smf.xs"
	char* CLASS = "Pac::Lattices";
	RETVAL = THIS->lattices();
#line 421 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemKey_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemKey_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacElemKey *	THIS;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemKey *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemKey::DESTROY() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	delete THIS;
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Pac__ElemKey_key); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemKey_key)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacElemKey *	THIS;
	int	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemKey *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemKey::key() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->key();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemKey_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemKey_name)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacElemKey *	THIS;
	char *	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemKey *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemKey::name() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 142 "Smf.xs"
	int l = THIS->name().length();
        RETVAL = new char[l + 1];
	strncpy(RETVAL, THIS->name().c_str(), l);
	RETVAL[l] = '\0';
#line 501 "Smf.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemKeys_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemKeys_size)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacElemKeys *	THIS;
	int	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemKeys *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemKeys::size() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->size();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemKeys_begin); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemKeys_begin)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacElemKeys *	THIS;
	PacElemKeyIterator *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemKeys *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemKeys::begin() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 158 "Smf.xs"
	char* CLASS = "Pac::ElemKeyIterator";
	RETVAL = new PacElemKeyIterator(THIS->begin());
#line 554 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemKeys_end); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemKeys_end)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacElemKeys *	THIS;
	PacElemKeyIterator *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemKeys *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemKeys::end() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 166 "Smf.xs"
	char* CLASS = "Pac::ElemKeyIterator";
	RETVAL = new PacElemKeyIterator(THIS->end());
#line 582 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemKeys_find); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemKeys_find)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, key");
    {
	int	key = (int)SvIV(ST(1))
;
	PacElemKeys *	THIS;
	PacElemKeyIterator *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemKeys *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemKeys::find() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 175 "Smf.xs"
	char* CLASS = "Pac::ElemKeyIterator";
	RETVAL = new PacElemKeyIterator(THIS->find(key));
#line 612 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemKeyIterator_add); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemKeyIterator_add)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	PacElemKeyIterator *	THIS;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemKeyIterator *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemKeyIterator::add() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 186 "Smf.xs"
	++(*THIS);
#line 638 "Smf.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Pac__ElemKeyIterator_ne); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemKeyIterator_ne)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, i, f");
    {
	PacElemKeyIterator*	i;
	int	f = (int)SvIV(ST(2))
;
	PacElemKeyIterator *	THIS;
	int	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		i = (PacElemKeyIterator *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Pac::ElemKeyIterator::ne() -- i is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemKeyIterator *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemKeyIterator::ne() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 193 "Smf.xs"
	RETVAL = *THIS != *i;
#line 675 "Smf.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemKeyIterator_first); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemKeyIterator_first)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacElemKeyIterator *	THIS;
	int	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemKeyIterator *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemKeyIterator::first() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 200 "Smf.xs"
	RETVAL = (THIS->operator*()).key();
#line 702 "Smf.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemKeyIterator_second); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemKeyIterator_second)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacElemKeyIterator *	THIS;
	PacElemKey *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemKeyIterator *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemKeyIterator::second() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 207 "Smf.xs"
	char* CLASS = "Pac::ElemKey";
	RETVAL = new PacElemKey(THIS->operator*());
#line 729 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemBucketKey_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemBucketKey_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacElemBucketKey *	THIS;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemBucketKey *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemBucketKey::DESTROY() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	delete THIS;
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Pac__ElemBucketKey_key); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemBucketKey_key)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacElemBucketKey *	THIS;
	int	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemBucketKey *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemBucketKey::key() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->key();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemBucketKey_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemBucketKey_name)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacElemBucketKey *	THIS;
	char *	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemBucketKey *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemBucketKey::name() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 223 "Smf.xs"
	int l = THIS->name().length();
        RETVAL = new char[l + 1];
	strncpy(RETVAL, THIS->name().c_str(), l);
	RETVAL[l] = '\0';
#line 809 "Smf.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemBucketKey_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemBucketKey_size)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacElemBucketKey *	THIS;
	int	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemBucketKey *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemBucketKey::size() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->size();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemBucketKey_order); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemBucketKey_order)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacElemBucketKey *	THIS;
	int	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemBucketKey *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemBucketKey::order() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->order();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemBucketKey_attribKey); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemBucketKey_attribKey)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	PacElemBucketKey *	THIS;
	PacElemAttribKey *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemBucketKey *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemBucketKey::attribKey() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 239 "Smf.xs"
	char* CLASS = "Pac::ElemAttribKey";
	if(items == 2) RETVAL = new PacElemAttribKey(THIS->operator[]( (int) SvIV(ST(1))) );
        if(items == 3) RETVAL = new PacElemAttribKey(THIS->operator[]( (int) SvIV(ST(1)))( (int) SvIV(ST(2))) );
#line 889 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemBucketKeys_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemBucketKeys_size)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacElemBucketKeys *	THIS;
	int	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemBucketKeys *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemBucketKeys::size() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->size();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemBucketKeys_begin); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemBucketKeys_begin)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacElemBucketKeys *	THIS;
	PacElemBucketKeyIterator *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemBucketKeys *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemBucketKeys::begin() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 253 "Smf.xs"
	char* CLASS = "Pac::ElemBucketKeyIterator";
	RETVAL = new PacElemBucketKeyIterator(THIS->begin());
#line 943 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemBucketKeys_end); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemBucketKeys_end)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacElemBucketKeys *	THIS;
	PacElemBucketKeyIterator *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemBucketKeys *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemBucketKeys::end() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 261 "Smf.xs"
	char* CLASS = "Pac::ElemBucketKeyIterator";
	RETVAL = new PacElemBucketKeyIterator(THIS->end());
#line 971 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemBucketKeys_find); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemBucketKeys_find)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, key");
    {
	int	key = (int)SvIV(ST(1))
;
	PacElemBucketKeys *	THIS;
	PacElemBucketKeyIterator *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemBucketKeys *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemBucketKeys::find() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 270 "Smf.xs"
	char* CLASS = "Pac::ElemBucketKeyIterator";
	RETVAL = new PacElemBucketKeyIterator(THIS->find(key));
#line 1001 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemBucketKeyIterator_add); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemBucketKeyIterator_add)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	PacElemBucketKeyIterator *	THIS;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemBucketKeyIterator *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemBucketKeyIterator::add() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 281 "Smf.xs"
	++(*THIS);
#line 1027 "Smf.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Pac__ElemBucketKeyIterator_ne); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemBucketKeyIterator_ne)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, i, f");
    {
	PacElemBucketKeyIterator*	i;
	int	f = (int)SvIV(ST(2))
;
	PacElemBucketKeyIterator *	THIS;
	int	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		i = (PacElemBucketKeyIterator *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Pac::ElemBucketKeyIterator::ne() -- i is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemBucketKeyIterator *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemBucketKeyIterator::ne() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 288 "Smf.xs"
	RETVAL = *THIS != *i;
#line 1064 "Smf.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemBucketKeyIterator_first); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemBucketKeyIterator_first)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacElemBucketKeyIterator *	THIS;
	int	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemBucketKeyIterator *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemBucketKeyIterator::first() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 295 "Smf.xs"
	RETVAL = (THIS->operator*()).key();
#line 1091 "Smf.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemBucketKeyIterator_second); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemBucketKeyIterator_second)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacElemBucketKeyIterator *	THIS;
	PacElemBucketKey *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemBucketKeyIterator *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemBucketKeyIterator::second() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 302 "Smf.xs"
	char* CLASS = "Pac::ElemBucketKey";
	RETVAL = new PacElemBucketKey(THIS->operator*());
#line 1118 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemAttribKey_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemAttribKey_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacElemAttribKey *	THIS;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemAttribKey *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemAttribKey::DESTROY() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	delete THIS;
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Pac__ElemAttribKey_bucketKey); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemAttribKey_bucketKey)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacElemAttribKey *	THIS;
	PacElemBucketKey *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemAttribKey *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemAttribKey::bucketKey() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 315 "Smf.xs"
	char* CLASS = "Pac::ElemBucketKey";
	RETVAL = new PacElemBucketKey(THIS->bucketKey());
#line 1169 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemAttribKey_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemAttribKey_name)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacElemAttribKey *	THIS;
	char *	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemAttribKey *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemAttribKey::name() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 323 "Smf.xs"
	int l = THIS->name().length();
        RETVAL = new char[l + 1];
	strncpy(RETVAL, THIS->name().c_str(), l);
	RETVAL[l] = '\0';
#line 1200 "Smf.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemAttribKey_index); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemAttribKey_index)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacElemAttribKey *	THIS;
	int	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemAttribKey *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemAttribKey::index() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->index();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemAttribKey_order); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemAttribKey_order)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacElemAttribKey *	THIS;
	int	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemAttribKey *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemAttribKey::order() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->order();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemAttribKey_multiply); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemAttribKey_multiply)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	PacElemAttribKey *	THIS;
	PacElemBucket *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemAttribKey *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemAttribKey::multiply() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 339 "Smf.xs"
	char* CLASS = "Pac::ElemBucket";
	RETVAL = new PacElemBucket((*THIS)*((double) SvNV(ST(1))));
#line 1279 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemBucket_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemBucket_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacElemBucket *	THIS;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemBucket *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemBucket::DESTROY() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	delete THIS;
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Pac__ElemBucket_key); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemBucket_key)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacElemBucket *	THIS;
	int	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemBucket *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemBucket::key() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->key();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemBucket_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemBucket_size)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacElemBucket *	THIS;
	int	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemBucket *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemBucket::size() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->size();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemBucket_value); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemBucket_value)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, index");
    {
	int	index = (int)SvIV(ST(1))
;
	PacElemBucket *	THIS;
	double	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemBucket *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemBucket::value() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 359 "Smf.xs"
	RETVAL = THIS->operator[](index);
#line 1384 "Smf.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemAttributes_begin); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemAttributes_begin)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacElemAttributes *	THIS;
	PacElemAttribIterator *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemAttributes *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemAttributes::begin() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 369 "Smf.xs"
	char* CLASS = "Pac::ElemAttribIterator";
	RETVAL = new PacElemAttribIterator(THIS->begin());
#line 1411 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemAttributes_end); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemAttributes_end)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacElemAttributes *	THIS;
	PacElemAttribIterator *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemAttributes *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemAttributes::end() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 377 "Smf.xs"
	char* CLASS = "Pac::ElemAttribIterator";
	RETVAL = new PacElemAttribIterator(THIS->end());
#line 1439 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemAttributes_find); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemAttributes_find)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, key");
    {
	int	key = (int)SvIV(ST(1))
;
	PacElemAttributes *	THIS;
	PacElemAttribIterator *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemAttributes *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemAttributes::find() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 386 "Smf.xs"
	char* CLASS = "Pac::ElemAttribIterator";
	RETVAL = new PacElemAttribIterator(THIS->find(key));
#line 1469 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemAttributes_set); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemAttributes_set)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	PacElemAttributes *	THIS;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemAttributes *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemAttributes::set() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 394 "Smf.xs"
	THIS->erase(THIS->begin(),THIS->end());

	for(int i=1; i < items; i++){
            if(sv_isa(ST(i), "Pac::ElemBucket") && (SvTYPE(SvRV(ST(i))) == SVt_PVMG) )
	    {
                THIS->add( *((PacElemBucket *) SvIV((SV*) SvRV( ST(i) ))) );
            } 
	    else{ 
	       if(sv_isa(ST(i), "Pac::ElemAttributes") && (SvTYPE(SvRV(ST(i))) == SVt_PVMG) )
 	       {
                   THIS->add( *((PacElemAttributes *) SvIV((SV*) SvRV( ST(i) ))) );
               } 
               else
	       {
                  warn( "PacElemAttributes::set(...) -- arguments are not a blessed SV reference" );
                  XSRETURN_UNDEF;
               }
            }
        };
#line 1513 "Smf.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemAttributes_add); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemAttributes_add)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	PacElemAttributes *	THIS;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemAttributes *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemAttributes::add() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 419 "Smf.xs"
	for(int i=1; i < items; i++){
            if(sv_isa(ST(i), "Pac::ElemBucket") && (SvTYPE(SvRV(ST(i))) == SVt_PVMG) )
	    {
                THIS->add( *((PacElemBucket *) SvIV((SV*) SvRV( ST(i) ))) );
            } 
	    else{ 
	       if(sv_isa(ST(i), "Pac::ElemAttributes") && (SvTYPE(SvRV(ST(i))) == SVt_PVMG) )
 	       {
                   THIS->add( *((PacElemAttributes *) SvIV((SV*) SvRV( ST(i) ))) );
               } 
               else
	       {
                  warn( "PacElemAttributes::add(...) -- arguments are not a blessed SV reference" );
                  XSRETURN_UNDEF;
               }
            }
        };
#line 1553 "Smf.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemAttributes_get); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemAttributes_get)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, key");
    {
	PacElemAttribKey*	key;
	PacElemAttributes *	THIS;
	double	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		key = (PacElemAttribKey *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Pac::ElemAttributes::get() -- key is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemAttributes *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemAttributes::get() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 441 "Smf.xs"
	RETVAL = THIS->get(*key);
#line 1588 "Smf.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemAttributes_remove); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemAttributes_remove)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, key");
    {
	PacElemAttribKey*	key;
	PacElemAttributes *	THIS;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		key = (PacElemAttribKey *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Pac::ElemAttributes::remove() -- key is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemAttributes *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemAttributes::remove() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 449 "Smf.xs"
	THIS->remove(*key);
#line 1622 "Smf.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Pac__ElemAttribIterator_add); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemAttribIterator_add)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	PacElemAttribIterator *	THIS;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemAttribIterator *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemAttribIterator::add() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 456 "Smf.xs"
	++(*THIS);
#line 1646 "Smf.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Pac__ElemAttribIterator_ne); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemAttribIterator_ne)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, i, f");
    {
	PacElemAttribIterator*	i;
	int	f = (int)SvIV(ST(2))
;
	PacElemAttribIterator *	THIS;
	int	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		i = (PacElemAttribIterator *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Pac::ElemAttribIterator::ne() -- i is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemAttribIterator *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemAttribIterator::ne() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 463 "Smf.xs"
	RETVAL = *THIS != *i;
#line 1683 "Smf.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemAttribIterator_first); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemAttribIterator_first)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacElemAttribIterator *	THIS;
	int	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemAttribIterator *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemAttribIterator::first() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 470 "Smf.xs"
	RETVAL = (THIS->operator*()).key();
#line 1710 "Smf.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemAttribIterator_second); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemAttribIterator_second)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacElemAttribIterator *	THIS;
	PacElemBucket *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemAttribIterator *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemAttribIterator::second() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 477 "Smf.xs"
	char* CLASS = "Pac::ElemBucket";
	RETVAL = new PacElemBucket(THIS->operator*());
#line 1737 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemPart_set); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemPart_set)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	PacElemPart *	THIS;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemPart *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemPart::set() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 487 "Smf.xs"
	THIS->remove();

	for(int i=1; i < items; i++){
            if(sv_isa(ST(i), "Pac::ElemBucket") && (SvTYPE(SvRV(ST(i))) == SVt_PVMG) )
	    {
                THIS->add( *((PacElemBucket *) SvIV((SV*) SvRV( ST(i) ))) );
            } 
	    else{ 
	       if(sv_isa(ST(i), "Pac::ElemAttributes") && (SvTYPE(SvRV(ST(i))) == SVt_PVMG) )
 	       {
                   THIS->add( *((PacElemAttributes *) SvIV((SV*) SvRV( ST(i) ))) );
               } 
               else
	       {
                  warn( "PacElemPart::set(...) -- arguments are not a blessed SV reference" );
                  XSRETURN_UNDEF;
               }
            }
        };
#line 1781 "Smf.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemPart_add); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemPart_add)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	PacElemPart *	THIS;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemPart *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemPart::add() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 512 "Smf.xs"
	for(int i=1; i < items; i++){
            if(sv_isa(ST(i), "Pac::ElemBucket") && (SvTYPE(SvRV(ST(i))) == SVt_PVMG) )
	    {
                THIS->add( *((PacElemBucket *) SvIV((SV*) SvRV( ST(i) ))) );
            } 
	    else{ 
	       if(sv_isa(ST(i), "Pac::ElemAttributes") && (SvTYPE(SvRV(ST(i))) == SVt_PVMG) )
 	       {
                   THIS->add( *((PacElemAttributes *) SvIV((SV*) SvRV( ST(i) ))) );
               } 
               else
	       {
                  warn( "PacElemPart::add(...) -- arguments are not a blessed SV reference" );
                  XSRETURN_UNDEF;
               }
            }
        };
#line 1821 "Smf.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemPart_get); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemPart_get)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, key");
    {
	PacElemAttribKey*	key;
	PacElemPart *	THIS;
	double	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		key = (PacElemAttribKey *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Pac::ElemPart::get() -- key is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemPart *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemPart::get() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 534 "Smf.xs"
	RETVAL = THIS->get(*key);
#line 1856 "Smf.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemPart_remove); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemPart_remove)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, key");
    {
	PacElemAttribKey*	key;
	PacElemPart *	THIS;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		key = (PacElemAttribKey *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Pac::ElemPart::remove() -- key is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemPart *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemPart::remove() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 542 "Smf.xs"
	THIS->remove(*key);
#line 1890 "Smf.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Pac__ElemPart_attributes); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemPart_attributes)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacElemPart *	THIS;
	PacElemAttributes *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemPart *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemPart::attributes() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 547 "Smf.xs"
	char* CLASS = "Pac::ElemAttributes";
	RETVAL = &THIS->attributes();
#line 1916 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__ElemPart_rms); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__ElemPart_rms)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacElemPart *	THIS;
	PacElemAttributes *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacElemPart *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::ElemPart::rms() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 555 "Smf.xs"
	char* CLASS = "Pac::ElemAttributes";
	RETVAL = &THIS->rms();
#line 1944 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__GenElement_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__GenElement_new)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "CLASS, n, id");
    {
	char*	n = (char *)SvPV_nolen(ST(1))
;
	int	id = (int)SvIV(ST(2))
;
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	PacGenElement *	RETVAL;

	RETVAL = new PacGenElement(n, id);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__GenElement_copy); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__GenElement_copy)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, right");
    {
	PacGenElement*	right;
	PacGenElement *	THIS;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		right = (PacGenElement *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Pac::GenElement::copy() -- right is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacGenElement *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::GenElement::copy() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 571 "Smf.xs"
   PacElemPart* part;
   for(int i=0; i < 3; i++){
     part = right->getPart(i);
     if(part) { THIS->setPart(i)->set(part->attributes()); }
  }
#line 2006 "Smf.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Pac__GenElement_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__GenElement_name)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacGenElement *	THIS;
	char *	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacGenElement *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::GenElement::name() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 580 "Smf.xs"
	int l = THIS->name().length();
        RETVAL = new char[l + 1];
	strncpy(RETVAL, THIS->name().c_str(), l);
	RETVAL[l] = '\0';
#line 2035 "Smf.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__GenElement_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__GenElement_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacGenElement *	THIS;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacGenElement *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::GenElement::DESTROY() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	delete THIS;
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Pac__GenElement_key); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__GenElement_key)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacGenElement *	THIS;
	int	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacGenElement *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::GenElement::key() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->key();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__GenElement_body); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__GenElement_body)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacGenElement *	THIS;
	PacElemPart *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacGenElement *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::GenElement::body() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 596 "Smf.xs"
	char* CLASS = "Pac::ElemPart";
	RETVAL = &THIS->body();
#line 2111 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__GenElement_front); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__GenElement_front)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacGenElement *	THIS;
	PacElemPart *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacGenElement *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::GenElement::front() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 604 "Smf.xs"
	char* CLASS = "Pac::ElemPart";
	RETVAL = &THIS->front();
#line 2139 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__GenElement_end); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__GenElement_end)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacGenElement *	THIS;
	PacElemPart *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacGenElement *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::GenElement::end() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 612 "Smf.xs"
	char* CLASS = "Pac::ElemPart";
	RETVAL = &THIS->end();
#line 2167 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__GenElement_getPart); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__GenElement_getPart)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, index");
    {
	int	index = (int)SvIV(ST(1))
;
	PacGenElement *	THIS;
	PacElemPart *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacGenElement *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::GenElement::getPart() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 621 "Smf.xs"
	char* CLASS = "Pac::ElemPart";
	RETVAL = THIS->getPart(index);
#line 2197 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__GenElement_rms); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__GenElement_rms)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacGenElement *	THIS;
	PacElemAttributes *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacGenElement *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::GenElement::rms() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 629 "Smf.xs"
	char* CLASS = "Pac::ElemAttributes";
	RETVAL = &THIS->rms();
#line 2225 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__GenElement_set); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__GenElement_set)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	PacGenElement *	THIS;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacGenElement *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::GenElement::set() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 637 "Smf.xs"
	THIS->remove();

	for(int i=1; i < items; i++){
            if(sv_isa(ST(i), "Pac::ElemBucket") && (SvTYPE(SvRV(ST(i))) == SVt_PVMG) )
	    {
                THIS->add( *((PacElemBucket *) SvIV((SV*) SvRV( ST(i) ))) );
            } 
	    else{ 
	       if(sv_isa(ST(i), "Pac::ElemAttributes") && (SvTYPE(SvRV(ST(i))) == SVt_PVMG) )
 	       {
                   THIS->add( *((PacElemAttributes *) SvIV((SV*) SvRV( ST(i) ))) );
               } 
               else
	       {
                  warn( "PacGenElement::set(...) -- arguments are not a blessed SV reference" );
                  XSRETURN_UNDEF;
               }
            }
        };
#line 2269 "Smf.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__GenElement_add); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__GenElement_add)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	PacGenElement *	THIS;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacGenElement *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::GenElement::add() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 662 "Smf.xs"
	for(int i=1; i < items; i++){
            if(sv_isa(ST(i), "Pac::ElemBucket") && (SvTYPE(SvRV(ST(i))) == SVt_PVMG) )
	    {
                THIS->add( *((PacElemBucket *) SvIV((SV*) SvRV( ST(i) ))) );
            } 
	    else{ 
	       if(sv_isa(ST(i), "Pac::ElemAttributes") && (SvTYPE(SvRV(ST(i))) == SVt_PVMG) )
 	       {
                   THIS->add( *((PacElemAttributes *) SvIV((SV*) SvRV( ST(i) ))) );
               } 
               else
	       {
                  warn( "PacGenElement::add(...) -- arguments are not a blessed SV reference" );
                  XSRETURN_UNDEF;
               }
            }
        };
#line 2309 "Smf.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__GenElement_get); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__GenElement_get)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, key");
    {
	PacElemAttribKey*	key;
	PacGenElement *	THIS;
	double	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		key = (PacElemAttribKey *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Pac::GenElement::get() -- key is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacGenElement *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::GenElement::get() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 684 "Smf.xs"
	RETVAL = THIS->get(*key);
#line 2344 "Smf.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__GenElement_remove); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__GenElement_remove)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, key");
    {
	PacElemAttribKey*	key;
	PacGenElement *	THIS;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		key = (PacElemAttribKey *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Pac::GenElement::remove() -- key is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacGenElement *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::GenElement::remove() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 692 "Smf.xs"
	THIS->remove(*key);
#line 2378 "Smf.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Pac__GenElement_map); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__GenElement_map)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, vtps");
    {
	VTps*	vtps;
	PacGenElement *	THIS;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		vtps = (VTps *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Pac::GenElement::map() -- vtps is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacGenElement *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::GenElement::map() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 698 "Smf.xs"
        PacVTps ptps(*vtps);
        THIS->map(ptps); 
#line 2412 "Smf.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Pac__GenElements_declare); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__GenElements_declare)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	PacGenElements *	THIS;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacGenElements *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::GenElements::declare() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 708 "Smf.xs"
	PacElemKey* key;

        if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
                { key  = (PacElemKey *) SvIV((SV*) SvRV( ST(1) )); }
        else{
                warn( "PacGenElements::declare(...) -- first argument is not a blessed SV reference" );
                XSRETURN_UNDEF;
        };

	int id = key->key();

        char*  n; 
        int    l;
        char   tmpChr1[80];
        char   tmpChr2[80];
	for(int i = 2; i < items; i++){
	   n = (char *) SvPV(ST(i), PL_na); l =  strlen(n);
           strncpy(tmpChr1, n, l); tmpChr1[l] = '\0';
           sprintf(tmpChr2, "main::%s\0", tmpChr1 );
	   sv_setref_pv(perl_get_sv(tmpChr2, TRUE), "Pac::GenElement", (void*) new PacGenElement(n, id));
	}
#line 2456 "Smf.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__GenElements_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__GenElements_size)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacGenElements *	THIS;
	int	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacGenElements *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::GenElements::size() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->size();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__GenElements_begin); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__GenElements_begin)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacGenElements *	THIS;
	PacGenElemIterator *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacGenElements *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::GenElements::begin() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 736 "Smf.xs"
	char* CLASS = "Pac::GenElemIterator";
	RETVAL = new PacGenElemIterator(THIS->begin());
#line 2508 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__GenElements_end); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__GenElements_end)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacGenElements *	THIS;
	PacGenElemIterator *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacGenElements *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::GenElements::end() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 744 "Smf.xs"
	char* CLASS = "Pac::GenElemIterator";
	RETVAL = new PacGenElemIterator(THIS->end());
#line 2536 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__GenElements_find); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__GenElements_find)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, key");
    {
	char*	key = (char *)SvPV_nolen(ST(1))
;
	PacGenElements *	THIS;
	PacGenElemIterator *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacGenElements *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::GenElements::find() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 753 "Smf.xs"
	char* CLASS = "Pac::GenElemIterator";
	RETVAL = new PacGenElemIterator(THIS->find(string(key)));
#line 2566 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__GenElemIterator_add); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__GenElemIterator_add)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	PacGenElemIterator *	THIS;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacGenElemIterator *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::GenElemIterator::add() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 764 "Smf.xs"
	++(*THIS);
#line 2592 "Smf.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Pac__GenElemIterator_ne); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__GenElemIterator_ne)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, i, f");
    {
	PacGenElemIterator*	i;
	int	f = (int)SvIV(ST(2))
;
	PacGenElemIterator *	THIS;
	int	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		i = (PacGenElemIterator *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Pac::GenElemIterator::ne() -- i is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacGenElemIterator *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::GenElemIterator::ne() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 771 "Smf.xs"
	RETVAL = *THIS != *i;
#line 2629 "Smf.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__GenElemIterator_first); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__GenElemIterator_first)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacGenElemIterator *	THIS;
	char *	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacGenElemIterator *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::GenElemIterator::first() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 778 "Smf.xs"
	int l = (THIS->operator*()).name().length();
        RETVAL = new char[l + 1];
	strncpy(RETVAL, (THIS->operator*()).name().c_str(), l);
	RETVAL[l] = '\0';	
#line 2659 "Smf.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__GenElemIterator_second); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__GenElemIterator_second)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacGenElemIterator *	THIS;
	PacGenElement *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacGenElemIterator *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::GenElemIterator::second() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 788 "Smf.xs"
	char* CLASS = "Pac::GenElement";
	RETVAL = new PacGenElement(THIS->operator*());
#line 2686 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__Line_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__Line_new)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "CLASS, n");
    {
	char*	n = (char *)SvPV_nolen(ST(1))
;
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	PacLine *	RETVAL;

	RETVAL = new PacLine(n);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__Line_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__Line_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacLine *	THIS;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLine *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::Line::DESTROY() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	delete THIS;
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Pac__Line_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__Line_name)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacLine *	THIS;
	char *	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLine *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::Line::name() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 805 "Smf.xs"
	int l = THIS->name().length();
        RETVAL = new char[l + 1];
	strncpy(RETVAL, THIS->name().c_str(), l);
	RETVAL[l] = '\0';
#line 2761 "Smf.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__Line_set); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__Line_set)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	PacLine *	THIS;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLine *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::Line::set() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 815 "Smf.xs"
	THIS->erase();
	for(int i=1; i < items; i++){
            if(sv_isa(ST(i), "Pac::GenElement") && (SvTYPE(SvRV(ST(i))) == SVt_PVMG) )
	    {
                THIS->add( *((PacGenElement *) SvIV((SV*) SvRV( ST(i) ))) );
            } 
	    else{ 
	       if(sv_isa(ST(i), "Pac::Line") && (SvTYPE(SvRV(ST(i))) == SVt_PVMG) )
 	       {
                   THIS->add( *((PacLine *) SvIV((SV*) SvRV( ST(i) ))) );
               } 
               else
	       {
                  warn( "PacLine::set(...) -- arguments are not a blessed SV reference" );
                  XSRETURN_UNDEF;
               }
            }
        };
#line 2803 "Smf.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__Line_add); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__Line_add)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	PacLine *	THIS;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLine *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::Line::add() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 837 "Smf.xs"
	for(int i=1; i < items; i++){
            if(sv_isa(ST(i), "Pac::GenElement") && (SvTYPE(SvRV(ST(i))) == SVt_PVMG) )
	    {
                THIS->add( *((PacGenElement *) SvIV((SV*) SvRV( ST(i) ))) );
            } 
	    else{ 
	       if(sv_isa(ST(i), "Pac::Line") && (SvTYPE(SvRV(ST(i))) == SVt_PVMG) )
 	       {
                   THIS->add( *((PacLine *) SvIV((SV*) SvRV( ST(i) ))) );
               } 
               else
	       {
                  warn( "PacLine::add(...) -- arguments are not a blessed SV reference" );
                  XSRETURN_UNDEF;
               }
            }
        };
#line 2843 "Smf.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__Line_multiply); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__Line_multiply)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	PacLine *	THIS;
	PacLine *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLine *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::Line::multiply() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 858 "Smf.xs"
	char* CLASS = "Pac::Line";
	RETVAL = new PacLine( ((int) SvIV(ST(1)))*(*THIS) );
#line 2869 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__Lines_declare); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__Lines_declare)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	PacLines *	THIS;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLines *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::Lines::declare() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 869 "Smf.xs"
	char* n;
	for(int i = 1; i < items; i++){
	   n = (char *) SvPV(ST(i), PL_na);
	   sv_setref_pv(perl_get_sv(n, TRUE), "Pac::Line", (void*) new PacLine(n));
	}
#line 2899 "Smf.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Pac__Lines_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__Lines_size)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacLines *	THIS;
	int	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLines *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::Lines::size() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->size();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__Lines_begin); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__Lines_begin)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacLines *	THIS;
	PacLineIterator *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLines *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::Lines::begin() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 881 "Smf.xs"
	char* CLASS = "Pac::LineIterator";
	RETVAL = new PacLineIterator(THIS->begin());
#line 2951 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__Lines_end); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__Lines_end)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacLines *	THIS;
	PacLineIterator *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLines *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::Lines::end() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 889 "Smf.xs"
	char* CLASS = "Pac::LineIterator";
	RETVAL = new PacLineIterator(THIS->end());
#line 2979 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__Lines_find); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__Lines_find)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, key");
    {
	char*	key = (char *)SvPV_nolen(ST(1))
;
	PacLines *	THIS;
	PacLineIterator *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLines *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::Lines::find() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 898 "Smf.xs"
	char* CLASS = "Pac::LineIterator";
	RETVAL = new PacLineIterator(THIS->find(string(key)));
#line 3009 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__LineIterator_add); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__LineIterator_add)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	PacLineIterator *	THIS;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLineIterator *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::LineIterator::add() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 909 "Smf.xs"
	++(*THIS);
#line 3035 "Smf.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Pac__LineIterator_ne); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__LineIterator_ne)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, i, f");
    {
	PacLineIterator*	i;
	int	f = (int)SvIV(ST(2))
;
	PacLineIterator *	THIS;
	int	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		i = (PacLineIterator *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Pac::LineIterator::ne() -- i is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLineIterator *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::LineIterator::ne() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 917 "Smf.xs"
	RETVAL = *THIS != *i;
#line 3072 "Smf.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__LineIterator_first); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__LineIterator_first)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacLineIterator *	THIS;
	char *	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLineIterator *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::LineIterator::first() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 924 "Smf.xs"
	int l = (THIS->operator*()).name().length();
        RETVAL = new char[l + 1];
	strncpy(RETVAL, (THIS->operator*()).name().c_str(), l);
	RETVAL[l] = '\0';
#line 3102 "Smf.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__LineIterator_second); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__LineIterator_second)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacLineIterator *	THIS;
	PacLine *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLineIterator *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::LineIterator::second() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 934 "Smf.xs"
	char* CLASS = "Pac::Line";
	RETVAL = new PacLine(THIS->operator*());
#line 3129 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__LattElement_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__LattElement_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacLattElement *	THIS;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLattElement *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::LattElement::DESTROY() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	delete THIS;
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Pac__LattElement_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__LattElement_new)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "CLASS, genElement");
    {
	PacGenElement*	genElement;
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	PacLattElement *	RETVAL;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		genElement = (PacGenElement *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Pac::LattElement::new() -- genElement is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 948 "Smf.xs"
        RETVAL = new PacLattElement(*genElement);
#line 3181 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__LattElement_setName); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__LattElement_setName)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, name");
    {
	char*	name = (char *)SvPV_nolen(ST(1))
;
	PacLattElement *	THIS;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLattElement *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::LattElement::setName() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 956 "Smf.xs"
	THIS->name(string(name));
#line 3209 "Smf.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Pac__LattElement_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__LattElement_name)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacLattElement *	THIS;
	char *	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLattElement *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::LattElement::name() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 961 "Smf.xs"
	int l = THIS->name().length();
        RETVAL = new char[l + 1];
	strncpy(RETVAL, THIS->name().c_str(), l);
	RETVAL[l] = '\0';
#line 3238 "Smf.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__LattElement_type); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__LattElement_type)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacLattElement *	THIS;
	char *	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLattElement *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::LattElement::type() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 971 "Smf.xs"
	int l = THIS->type().length();
        RETVAL = new char[l + 1];
	strncpy(RETVAL, THIS->type().c_str(), l);
	RETVAL[l] = '\0';
#line 3268 "Smf.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__LattElement_genName); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__LattElement_genName)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacLattElement *	THIS;
	char *	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLattElement *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::LattElement::genName() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 982 "Smf.xs"
	int l = THIS->genElement().name().length();
        RETVAL = new char[l + 1];
	strncpy(RETVAL, THIS->genElement().name().c_str(), l);
	RETVAL[l] = '\0';	
#line 3298 "Smf.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__LattElement_key); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__LattElement_key)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacLattElement *	THIS;
	int	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLattElement *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::LattElement::key() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 992 "Smf.xs"
	RETVAL = THIS->genElement().key();
#line 3325 "Smf.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__LattElement_body); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__LattElement_body)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacLattElement *	THIS;
	PacElemAttributes *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLattElement *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::LattElement::body() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 999 "Smf.xs"
	char* CLASS = "Pac::ElemAttributes";
	RETVAL = &THIS->body();
#line 3352 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__LattElement_front); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__LattElement_front)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacLattElement *	THIS;
	PacElemAttributes *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLattElement *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::LattElement::front() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 1007 "Smf.xs"
	char* CLASS = "Pac::ElemAttributes";
	RETVAL = &THIS->front();
#line 3380 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__LattElement_end); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__LattElement_end)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacLattElement *	THIS;
	PacElemAttributes *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLattElement *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::LattElement::end() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 1015 "Smf.xs"
	char* CLASS = "Pac::ElemAttributes";
	RETVAL = &THIS->end();
#line 3408 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__LattElement_getPart); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__LattElement_getPart)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, index");
    {
	int	index = (int)SvIV(ST(1))
;
	PacLattElement *	THIS;
	PacElemAttributes *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLattElement *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::LattElement::getPart() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 1024 "Smf.xs"
	char* CLASS = "Pac::ElemAttributes";
	RETVAL = THIS->getPart(index);
#line 3438 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__LattElement_set); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__LattElement_set)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	PacLattElement *	THIS;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLattElement *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::LattElement::set() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 1032 "Smf.xs"
	THIS->remove();

	for(int i=1; i < items; i++){
            if(sv_isa(ST(i), "Pac::ElemBucket") && (SvTYPE(SvRV(ST(i))) == SVt_PVMG) )
	    {
                THIS->add( *((PacElemBucket *) SvIV((SV*) SvRV( ST(i) ))) );
            } 
	    else{ 
	       if(sv_isa(ST(i), "Pac::ElemAttributes") && (SvTYPE(SvRV(ST(i))) == SVt_PVMG) )
 	       {
                   THIS->add( *((PacElemAttributes *) SvIV((SV*) SvRV( ST(i) ))) );
               } 
               else
	       {
                  warn( "PacLattElement::set(...) -- arguments are not a blessed SV reference" );
                  XSRETURN_UNDEF;
               }
            }
        };
#line 3482 "Smf.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__LattElement_add); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__LattElement_add)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	PacLattElement *	THIS;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLattElement *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::LattElement::add() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 1057 "Smf.xs"
	for(int i=1; i < items; i++){
            if(sv_isa(ST(i), "Pac::ElemBucket") && (SvTYPE(SvRV(ST(i))) == SVt_PVMG) )
	    {
                THIS->add( *((PacElemBucket *) SvIV((SV*) SvRV( ST(i) ))) );
            } 
	    else{ 
	       if(sv_isa(ST(i), "Pac::ElemAttributes") && (SvTYPE(SvRV(ST(i))) == SVt_PVMG) )
 	       {
                   THIS->add( *((PacElemAttributes *) SvIV((SV*) SvRV( ST(i) ))) );
               } 
               else
	       {
                  warn( "PacLattElement::add(...) -- arguments are not a blessed SV reference" );
                  XSRETURN_UNDEF;
               }
            }
        };
#line 3522 "Smf.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__LattElement_get); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__LattElement_get)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, key");
    {
	PacElemAttribKey*	key;
	PacLattElement *	THIS;
	double	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		key = (PacElemAttribKey *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Pac::LattElement::get() -- key is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLattElement *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::LattElement::get() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 1079 "Smf.xs"
	RETVAL = THIS->get(*key);
#line 3557 "Smf.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__LattElement_remove); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__LattElement_remove)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, key");
    {
	PacElemAttribKey*	key;
	PacLattElement *	THIS;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		key = (PacElemAttribKey *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Pac::LattElement::remove() -- key is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLattElement *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::LattElement::remove() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 1087 "Smf.xs"
	THIS->remove(*key);
#line 3591 "Smf.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Pac__Lattice_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__Lattice_new)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "CLASS, n");
    {
	char*	n = (char *)SvPV_nolen(ST(1))
;
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	PacLattice *	RETVAL;

	RETVAL = new PacLattice(n);
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__Lattice_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__Lattice_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacLattice *	THIS;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLattice *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::Lattice::DESTROY() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	delete THIS;
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Pac__Lattice_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__Lattice_name)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacLattice *	THIS;
	char *	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLattice *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::Lattice::name() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 1101 "Smf.xs"
	int l = THIS->name().length();
        RETVAL = new char[l + 1];
	strncpy(RETVAL, THIS->name().c_str(), l);
	RETVAL[l] = '\0';
#line 3664 "Smf.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__Lattice_set); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__Lattice_set)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	PacLattice *	THIS;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLattice *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::Lattice::set() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 1111 "Smf.xs"
	for(int i=1; i < items; i++){
            if(sv_isa(ST(i), "Pac::Lattice") && (SvTYPE(SvRV(ST(i))) == SVt_PVMG) )
	    {
                THIS->add( *((PacLattice *) SvIV((SV*) SvRV( ST(i) ))) );
            } 
	    else{ 
	       if(i > 1) {
                  warn( "PacLattice::set(...) -- arguments are not  blessed Lattice references" );
                  XSRETURN_UNDEF;
               }		
	       if(sv_isa(ST(i), "Pac::Line") && (SvTYPE(SvRV(ST(i))) == SVt_PVMG) )
 	       {
                   THIS->set( *((PacLine *) SvIV((SV*) SvRV( ST(i) ))) );
               } 
               else
	       {
                  warn( "PacLattice::set(...) -- arguments are not a blessed Lattice reference" );
                  XSRETURN_UNDEF;
               }
            }
        };
#line 3709 "Smf.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__Lattice_add); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__Lattice_add)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	PacLattice *	THIS;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLattice *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::Lattice::add() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 1136 "Smf.xs"
	for(int i=1; i < items; i++){
            if(sv_isa(ST(i), "Pac::Lattice") && (SvTYPE(SvRV(ST(i))) == SVt_PVMG) )
	    {
                THIS->add( *((PacLattice *) SvIV((SV*) SvRV( ST(i) ))) );
            } 
            else
	    {
                warn( "PacLattice::add(...) -- arguments are not a blessed Lattice reference" );
                XSRETURN_UNDEF;
	    }
        };
#line 3743 "Smf.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__Lattice_element); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__Lattice_element)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, index");
    {
	int	index = (int)SvIV(ST(1))
;
	PacLattice *	THIS;
	PacLattElement *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLattice *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::Lattice::element() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 1152 "Smf.xs"
	char* CLASS = "Pac::LattElement";
	RETVAL = new PacLattElement();
	*RETVAL = (*THIS)[index];
#line 3772 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__Lattice_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__Lattice_size)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacLattice *	THIS;
	int	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLattice *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::Lattice::size() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->size();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__Lattices_declare); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__Lattices_declare)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	PacLattices *	THIS;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLattices *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::Lattices::declare() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 1167 "Smf.xs"
	char* n;
	for(int i = 1; i < items; i++){
	   n = (char *) SvPV(ST(i), PL_na);
	   sv_setref_pv(perl_get_sv(n, TRUE), "Pac::Lattice", (void*) new PacLattice(n));
	}
#line 3828 "Smf.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Pac__Lattices_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__Lattices_size)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacLattice *	THIS;
	int	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLattice *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::Lattices::size() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->size();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__Lattices_begin); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__Lattices_begin)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacLattices *	THIS;
	PacLatticeIterator *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLattices *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::Lattices::begin() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 1179 "Smf.xs"
	char* CLASS = "Pac::LatticeIterator";
	RETVAL = new PacLatticeIterator(THIS->begin());
#line 3880 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__Lattices_end); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__Lattices_end)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacLattices *	THIS;
	PacLatticeIterator *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLattices *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::Lattices::end() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 1187 "Smf.xs"
	char* CLASS = "Pac::LatticeIterator";
	RETVAL = new PacLatticeIterator(THIS->end());
#line 3908 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__Lattices_find); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__Lattices_find)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, key");
    {
	char*	key = (char *)SvPV_nolen(ST(1))
;
	PacLattices *	THIS;
	PacLatticeIterator *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLattices *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::Lattices::find() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 1196 "Smf.xs"
	char* CLASS = "Pac::LatticeIterator";
	RETVAL = new PacLatticeIterator(THIS->find(string(key)));
#line 3938 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__LatticeIterator_add); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__LatticeIterator_add)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	PacLatticeIterator *	THIS;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLatticeIterator *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::LatticeIterator::add() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 1206 "Smf.xs"
	++(*THIS);
#line 3964 "Smf.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Pac__LatticeIterator_ne); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__LatticeIterator_ne)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, i, f");
    {
	PacLatticeIterator*	i;
	int	f = (int)SvIV(ST(2))
;
	PacLatticeIterator *	THIS;
	int	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		i = (PacLatticeIterator *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Pac::LatticeIterator::ne() -- i is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLatticeIterator *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::LatticeIterator::ne() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 1214 "Smf.xs"
	RETVAL = *THIS != *i;
#line 4001 "Smf.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__LatticeIterator_first); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__LatticeIterator_first)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacLatticeIterator *	THIS;
	char *	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLatticeIterator *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::LatticeIterator::first() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 1221 "Smf.xs"
	int l = (THIS->operator*()).name().length();
        RETVAL = new char[l + 1];
	strncpy(RETVAL, (THIS->operator*()).name().c_str(), l);
	RETVAL[l] = '\0';	
#line 4031 "Smf.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pac__LatticeIterator_second); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pac__LatticeIterator_second)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PacLatticeIterator *	THIS;
	PacLattice *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (PacLatticeIterator *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Pac::LatticeIterator::second() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 1231 "Smf.xs"
	char* CLASS = "Pac::Lattice";
	RETVAL = new PacLattice(THIS->operator*());
#line 4058 "Smf.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Pac__Smf); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Pac__Smf)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

        (void)newXSproto_portable("Pac::Smf::create", XS_Pac__Smf_create, file, "");
        (void)newXSproto_portable("Pac::Smf::initialize", XS_Pac__Smf_initialize, file, "$");
        (void)newXSproto_portable("Pac::Smf::DESTROY", XS_Pac__Smf_DESTROY, file, "$");
        (void)newXSproto_portable("Pac::Smf::elemKeys", XS_Pac__Smf_elemKeys, file, "$");
        (void)newXSproto_portable("Pac::Smf::bucketKeys", XS_Pac__Smf_bucketKeys, file, "$");
        (void)newXSproto_portable("Pac::Smf::elements", XS_Pac__Smf_elements, file, "$");
        (void)newXSproto_portable("Pac::Smf::lines", XS_Pac__Smf_lines, file, "$");
        (void)newXSproto_portable("Pac::Smf::lattices", XS_Pac__Smf_lattices, file, "$");
        (void)newXSproto_portable("Pac::ElemKey::DESTROY", XS_Pac__ElemKey_DESTROY, file, "$");
        (void)newXSproto_portable("Pac::ElemKey::key", XS_Pac__ElemKey_key, file, "$");
        (void)newXSproto_portable("Pac::ElemKey::name", XS_Pac__ElemKey_name, file, "$");
        (void)newXSproto_portable("Pac::ElemKeys::size", XS_Pac__ElemKeys_size, file, "$");
        (void)newXSproto_portable("Pac::ElemKeys::begin", XS_Pac__ElemKeys_begin, file, "$");
        (void)newXSproto_portable("Pac::ElemKeys::end", XS_Pac__ElemKeys_end, file, "$");
        (void)newXSproto_portable("Pac::ElemKeys::find", XS_Pac__ElemKeys_find, file, "$$");
        (void)newXSproto_portable("Pac::ElemKeyIterator::add", XS_Pac__ElemKeyIterator_add, file, "$;@");
        (void)newXSproto_portable("Pac::ElemKeyIterator::ne", XS_Pac__ElemKeyIterator_ne, file, "$$$");
        (void)newXSproto_portable("Pac::ElemKeyIterator::first", XS_Pac__ElemKeyIterator_first, file, "$");
        (void)newXSproto_portable("Pac::ElemKeyIterator::second", XS_Pac__ElemKeyIterator_second, file, "$");
        (void)newXSproto_portable("Pac::ElemBucketKey::DESTROY", XS_Pac__ElemBucketKey_DESTROY, file, "$");
        (void)newXSproto_portable("Pac::ElemBucketKey::key", XS_Pac__ElemBucketKey_key, file, "$");
        (void)newXSproto_portable("Pac::ElemBucketKey::name", XS_Pac__ElemBucketKey_name, file, "$");
        (void)newXSproto_portable("Pac::ElemBucketKey::size", XS_Pac__ElemBucketKey_size, file, "$");
        (void)newXSproto_portable("Pac::ElemBucketKey::order", XS_Pac__ElemBucketKey_order, file, "$");
        (void)newXSproto_portable("Pac::ElemBucketKey::attribKey", XS_Pac__ElemBucketKey_attribKey, file, "$;@");
        (void)newXSproto_portable("Pac::ElemBucketKeys::size", XS_Pac__ElemBucketKeys_size, file, "$");
        (void)newXSproto_portable("Pac::ElemBucketKeys::begin", XS_Pac__ElemBucketKeys_begin, file, "$");
        (void)newXSproto_portable("Pac::ElemBucketKeys::end", XS_Pac__ElemBucketKeys_end, file, "$");
        (void)newXSproto_portable("Pac::ElemBucketKeys::find", XS_Pac__ElemBucketKeys_find, file, "$$");
        (void)newXSproto_portable("Pac::ElemBucketKeyIterator::add", XS_Pac__ElemBucketKeyIterator_add, file, "$;@");
        (void)newXSproto_portable("Pac::ElemBucketKeyIterator::ne", XS_Pac__ElemBucketKeyIterator_ne, file, "$$$");
        (void)newXSproto_portable("Pac::ElemBucketKeyIterator::first", XS_Pac__ElemBucketKeyIterator_first, file, "$");
        (void)newXSproto_portable("Pac::ElemBucketKeyIterator::second", XS_Pac__ElemBucketKeyIterator_second, file, "$");
        (void)newXSproto_portable("Pac::ElemAttribKey::DESTROY", XS_Pac__ElemAttribKey_DESTROY, file, "$");
        (void)newXSproto_portable("Pac::ElemAttribKey::bucketKey", XS_Pac__ElemAttribKey_bucketKey, file, "$");
        (void)newXSproto_portable("Pac::ElemAttribKey::name", XS_Pac__ElemAttribKey_name, file, "$");
        (void)newXSproto_portable("Pac::ElemAttribKey::index", XS_Pac__ElemAttribKey_index, file, "$");
        (void)newXSproto_portable("Pac::ElemAttribKey::order", XS_Pac__ElemAttribKey_order, file, "$");
        (void)newXSproto_portable("Pac::ElemAttribKey::multiply", XS_Pac__ElemAttribKey_multiply, file, "$;@");
        (void)newXSproto_portable("Pac::ElemBucket::DESTROY", XS_Pac__ElemBucket_DESTROY, file, "$");
        (void)newXSproto_portable("Pac::ElemBucket::key", XS_Pac__ElemBucket_key, file, "$");
        (void)newXSproto_portable("Pac::ElemBucket::size", XS_Pac__ElemBucket_size, file, "$");
        (void)newXSproto_portable("Pac::ElemBucket::value", XS_Pac__ElemBucket_value, file, "$$");
        (void)newXSproto_portable("Pac::ElemAttributes::begin", XS_Pac__ElemAttributes_begin, file, "$");
        (void)newXSproto_portable("Pac::ElemAttributes::end", XS_Pac__ElemAttributes_end, file, "$");
        (void)newXSproto_portable("Pac::ElemAttributes::find", XS_Pac__ElemAttributes_find, file, "$$");
        (void)newXSproto_portable("Pac::ElemAttributes::set", XS_Pac__ElemAttributes_set, file, "$;@");
        (void)newXSproto_portable("Pac::ElemAttributes::add", XS_Pac__ElemAttributes_add, file, "$;@");
        (void)newXSproto_portable("Pac::ElemAttributes::get", XS_Pac__ElemAttributes_get, file, "$$");
        (void)newXSproto_portable("Pac::ElemAttributes::remove", XS_Pac__ElemAttributes_remove, file, "$$");
        (void)newXSproto_portable("Pac::ElemAttribIterator::add", XS_Pac__ElemAttribIterator_add, file, "$;@");
        (void)newXSproto_portable("Pac::ElemAttribIterator::ne", XS_Pac__ElemAttribIterator_ne, file, "$$$");
        (void)newXSproto_portable("Pac::ElemAttribIterator::first", XS_Pac__ElemAttribIterator_first, file, "$");
        (void)newXSproto_portable("Pac::ElemAttribIterator::second", XS_Pac__ElemAttribIterator_second, file, "$");
        (void)newXSproto_portable("Pac::ElemPart::set", XS_Pac__ElemPart_set, file, "$;@");
        (void)newXSproto_portable("Pac::ElemPart::add", XS_Pac__ElemPart_add, file, "$;@");
        (void)newXSproto_portable("Pac::ElemPart::get", XS_Pac__ElemPart_get, file, "$$");
        (void)newXSproto_portable("Pac::ElemPart::remove", XS_Pac__ElemPart_remove, file, "$$");
        (void)newXSproto_portable("Pac::ElemPart::attributes", XS_Pac__ElemPart_attributes, file, "$");
        (void)newXSproto_portable("Pac::ElemPart::rms", XS_Pac__ElemPart_rms, file, "$");
        (void)newXSproto_portable("Pac::GenElement::new", XS_Pac__GenElement_new, file, "$$$");
        (void)newXSproto_portable("Pac::GenElement::copy", XS_Pac__GenElement_copy, file, "$$");
        (void)newXSproto_portable("Pac::GenElement::name", XS_Pac__GenElement_name, file, "$");
        (void)newXSproto_portable("Pac::GenElement::DESTROY", XS_Pac__GenElement_DESTROY, file, "$");
        (void)newXSproto_portable("Pac::GenElement::key", XS_Pac__GenElement_key, file, "$");
        (void)newXSproto_portable("Pac::GenElement::body", XS_Pac__GenElement_body, file, "$");
        (void)newXSproto_portable("Pac::GenElement::front", XS_Pac__GenElement_front, file, "$");
        (void)newXSproto_portable("Pac::GenElement::end", XS_Pac__GenElement_end, file, "$");
        (void)newXSproto_portable("Pac::GenElement::getPart", XS_Pac__GenElement_getPart, file, "$$");
        (void)newXSproto_portable("Pac::GenElement::rms", XS_Pac__GenElement_rms, file, "$");
        (void)newXSproto_portable("Pac::GenElement::set", XS_Pac__GenElement_set, file, "$;@");
        (void)newXSproto_portable("Pac::GenElement::add", XS_Pac__GenElement_add, file, "$;@");
        (void)newXSproto_portable("Pac::GenElement::get", XS_Pac__GenElement_get, file, "$$");
        (void)newXSproto_portable("Pac::GenElement::remove", XS_Pac__GenElement_remove, file, "$$");
        (void)newXSproto_portable("Pac::GenElement::map", XS_Pac__GenElement_map, file, "$$");
        (void)newXSproto_portable("Pac::GenElements::declare", XS_Pac__GenElements_declare, file, "$;@");
        (void)newXSproto_portable("Pac::GenElements::size", XS_Pac__GenElements_size, file, "$");
        (void)newXSproto_portable("Pac::GenElements::begin", XS_Pac__GenElements_begin, file, "$");
        (void)newXSproto_portable("Pac::GenElements::end", XS_Pac__GenElements_end, file, "$");
        (void)newXSproto_portable("Pac::GenElements::find", XS_Pac__GenElements_find, file, "$$");
        (void)newXSproto_portable("Pac::GenElemIterator::add", XS_Pac__GenElemIterator_add, file, "$;@");
        (void)newXSproto_portable("Pac::GenElemIterator::ne", XS_Pac__GenElemIterator_ne, file, "$$$");
        (void)newXSproto_portable("Pac::GenElemIterator::first", XS_Pac__GenElemIterator_first, file, "$");
        (void)newXSproto_portable("Pac::GenElemIterator::second", XS_Pac__GenElemIterator_second, file, "$");
        (void)newXSproto_portable("Pac::Line::new", XS_Pac__Line_new, file, "$$");
        (void)newXSproto_portable("Pac::Line::DESTROY", XS_Pac__Line_DESTROY, file, "$");
        (void)newXSproto_portable("Pac::Line::name", XS_Pac__Line_name, file, "$");
        (void)newXSproto_portable("Pac::Line::set", XS_Pac__Line_set, file, "$;@");
        (void)newXSproto_portable("Pac::Line::add", XS_Pac__Line_add, file, "$;@");
        (void)newXSproto_portable("Pac::Line::multiply", XS_Pac__Line_multiply, file, "$;@");
        (void)newXSproto_portable("Pac::Lines::declare", XS_Pac__Lines_declare, file, "$;@");
        (void)newXSproto_portable("Pac::Lines::size", XS_Pac__Lines_size, file, "$");
        (void)newXSproto_portable("Pac::Lines::begin", XS_Pac__Lines_begin, file, "$");
        (void)newXSproto_portable("Pac::Lines::end", XS_Pac__Lines_end, file, "$");
        (void)newXSproto_portable("Pac::Lines::find", XS_Pac__Lines_find, file, "$$");
        (void)newXSproto_portable("Pac::LineIterator::add", XS_Pac__LineIterator_add, file, "$;@");
        (void)newXSproto_portable("Pac::LineIterator::ne", XS_Pac__LineIterator_ne, file, "$$$");
        (void)newXSproto_portable("Pac::LineIterator::first", XS_Pac__LineIterator_first, file, "$");
        (void)newXSproto_portable("Pac::LineIterator::second", XS_Pac__LineIterator_second, file, "$");
        (void)newXSproto_portable("Pac::LattElement::DESTROY", XS_Pac__LattElement_DESTROY, file, "$");
        (void)newXSproto_portable("Pac::LattElement::new", XS_Pac__LattElement_new, file, "$$");
        (void)newXSproto_portable("Pac::LattElement::setName", XS_Pac__LattElement_setName, file, "$$");
        (void)newXSproto_portable("Pac::LattElement::name", XS_Pac__LattElement_name, file, "$");
        (void)newXSproto_portable("Pac::LattElement::type", XS_Pac__LattElement_type, file, "$");
        (void)newXSproto_portable("Pac::LattElement::genName", XS_Pac__LattElement_genName, file, "$");
        (void)newXSproto_portable("Pac::LattElement::key", XS_Pac__LattElement_key, file, "$");
        (void)newXSproto_portable("Pac::LattElement::body", XS_Pac__LattElement_body, file, "$");
        (void)newXSproto_portable("Pac::LattElement::front", XS_Pac__LattElement_front, file, "$");
        (void)newXSproto_portable("Pac::LattElement::end", XS_Pac__LattElement_end, file, "$");
        (void)newXSproto_portable("Pac::LattElement::getPart", XS_Pac__LattElement_getPart, file, "$$");
        (void)newXSproto_portable("Pac::LattElement::set", XS_Pac__LattElement_set, file, "$;@");
        (void)newXSproto_portable("Pac::LattElement::add", XS_Pac__LattElement_add, file, "$;@");
        (void)newXSproto_portable("Pac::LattElement::get", XS_Pac__LattElement_get, file, "$$");
        (void)newXSproto_portable("Pac::LattElement::remove", XS_Pac__LattElement_remove, file, "$$");
        (void)newXSproto_portable("Pac::Lattice::new", XS_Pac__Lattice_new, file, "$$");
        (void)newXSproto_portable("Pac::Lattice::DESTROY", XS_Pac__Lattice_DESTROY, file, "$");
        (void)newXSproto_portable("Pac::Lattice::name", XS_Pac__Lattice_name, file, "$");
        (void)newXSproto_portable("Pac::Lattice::set", XS_Pac__Lattice_set, file, "$;@");
        (void)newXSproto_portable("Pac::Lattice::add", XS_Pac__Lattice_add, file, "$;@");
        (void)newXSproto_portable("Pac::Lattice::element", XS_Pac__Lattice_element, file, "$$");
        (void)newXSproto_portable("Pac::Lattice::size", XS_Pac__Lattice_size, file, "$");
        (void)newXSproto_portable("Pac::Lattices::declare", XS_Pac__Lattices_declare, file, "$;@");
        (void)newXSproto_portable("Pac::Lattices::size", XS_Pac__Lattices_size, file, "$");
        (void)newXSproto_portable("Pac::Lattices::begin", XS_Pac__Lattices_begin, file, "$");
        (void)newXSproto_portable("Pac::Lattices::end", XS_Pac__Lattices_end, file, "$");
        (void)newXSproto_portable("Pac::Lattices::find", XS_Pac__Lattices_find, file, "$$");
        (void)newXSproto_portable("Pac::LatticeIterator::add", XS_Pac__LatticeIterator_add, file, "$;@");
        (void)newXSproto_portable("Pac::LatticeIterator::ne", XS_Pac__LatticeIterator_ne, file, "$$$");
        (void)newXSproto_portable("Pac::LatticeIterator::first", XS_Pac__LatticeIterator_first, file, "$");
        (void)newXSproto_portable("Pac::LatticeIterator::second", XS_Pac__LatticeIterator_second, file, "$");
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

