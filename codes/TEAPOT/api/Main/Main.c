/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.18 from the
 * contents of Main.xs. Do not edit this file, edit Main.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Main.xs"
#include <assert.h> 

#ifdef __cplusplus
extern "C" {
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#ifdef __cplusplus
}
#endif

#ifdef do_open
#undef do_open
#endif

#ifdef do_close
#undef do_close
#endif

#ifdef list
#undef list
#endif

#include "Main/Teapot.h"
#include "Integrator/TeapotIntegrator.h"
#include "Integrator/TeapotDAIntegrator.h"

using namespace PAC;

#line 41 "Main.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 183 "Main.c"

XS_EUPXS(XS_Teapot__Main_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Teapot__Main_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	Teapot *	RETVAL;

	RETVAL = new Teapot();
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Teapot__Main_use); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Teapot__Main_use)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, lattice");
    {
	PacLattice*	lattice;
	Teapot *	THIS;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		lattice = (PacLattice *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Teapot::Main::use() -- lattice is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (Teapot *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Teapot::Main::use() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 40 "Main.xs"
	THIS->use(*lattice);
#line 231 "Main.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Teapot__Main_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Teapot__Main_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Teapot *	THIS;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (Teapot *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Teapot::Main::DESTROY() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	delete THIS;
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Teapot__Main_makethin); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Teapot__Main_makethin)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Teapot *	THIS;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (Teapot *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Teapot::Main::makethin() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	THIS->makethin();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Teapot__Main_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Teapot__Main_size)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Teapot *	THIS;
	int	RETVAL;
	dXSTARG;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (Teapot *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Teapot::Main::size() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->size();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Teapot__Main_element); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Teapot__Main_element)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, index");
    {
	int	index = (int)SvIV(ST(1))
;
	Teapot *	THIS;
	PacLattElement *	RETVAL;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (Teapot *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Teapot::Main::element() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 55 "Main.xs"
	char* CLASS = "Pac::LattElement";
	RETVAL = new PacLattElement();
	*RETVAL = THIS->element(index);
#line 332 "Main.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Teapot__Main_track); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Teapot__Main_track)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	Teapot *	THIS;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (Teapot *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Teapot::Main::track() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 64 "Main.xs"
	if(items == 3){
            if(SvTYPE(SvRV(ST(1))) == SVt_PVMG)
	    {
                THIS->track(*((Bunch *) SvIV((SV*) SvRV( ST(1) ))), (int ) SvIV(ST(2)));
            } 
            else
	    {
                warn( "Teapot::track(bunch, turns) -- arguments are not a blessed SV reference" );
                XSRETURN_UNDEF;
            }
	}
	if(items == 4){
            if(SvTYPE(SvRV(ST(1))) == SVt_PVMG)
	    {
                THIS->track(*((Bunch *) SvIV((SV*) SvRV( ST(1) ))), (int ) SvIV(ST(2)), (int) SvIV(ST(3)) );
            } 
            else
	    {
                warn( "Teapot::track(bunch, i1, i2) -- arguments are not a blessed SV reference" );
                XSRETURN_UNDEF;
            }
	}
#line 379 "Main.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Teapot__Main_survey); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Teapot__Main_survey)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "THIS, s, i1, i2");
    {
	PacSurveyData*	s;
	int	i1 = (int)SvIV(ST(2))
;
	int	i2 = (int)SvIV(ST(3))
;
	Teapot *	THIS;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		s = (PacSurveyData *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Teapot::Main::survey() -- s is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (Teapot *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Teapot::Main::survey() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 93 "Main.xs"
	THIS->survey(*s, i1, i2);
#line 416 "Main.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Teapot__Main_clorbit); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Teapot__Main_clorbit)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, orbit, beam");
    {
	Position*	orbit;
	BeamAttributes*	beam;
	Teapot *	THIS;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		orbit = (Position *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Teapot::Main::clorbit() -- orbit is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) )
		beam = (BeamAttributes *) SvIV((SV*) SvRV( ST(2) ));
	else{
		warn( "Teapot::Main::clorbit() -- beam is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (Teapot *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Teapot::Main::clorbit() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 100 "Main.xs"
	THIS->clorbit(*orbit, *beam);
#line 458 "Main.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Teapot__Main_trackClorbit); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Teapot__Main_trackClorbit)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "THIS, orbit, beam, i1, i2");
    {
	Position*	orbit;
	BeamAttributes*	beam;
	int	i1 = (int)SvIV(ST(3))
;
	int	i2 = (int)SvIV(ST(4))
;
	Teapot *	THIS;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		orbit = (Position *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Teapot::Main::trackClorbit() -- orbit is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) )
		beam = (BeamAttributes *) SvIV((SV*) SvRV( ST(2) ));
	else{
		warn( "Teapot::Main::trackClorbit() -- beam is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (Teapot *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Teapot::Main::trackClorbit() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 109 "Main.xs"
	THIS->trackClorbit(*orbit, *beam, i1, i2);
#line 504 "Main.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Teapot__Main_steer_); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Teapot__Main_steer_)
{
    dVAR; dXSARGS;
    if (items != 7)
       croak_xs_usage(cv,  "THIS, orbit, beam, rads, rdets, method, plane");
    {
	Position*	orbit;
	BeamAttributes*	beam;
	SV*	rads = ST(3)
;
	SV*	rdets = ST(4)
;
	int	method = (int)SvIV(ST(5))
;
	char	plane = (char)*SvPV_nolen(ST(6))
;
	Teapot *	THIS;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		orbit = (Position *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Teapot::Main::steer_() -- orbit is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) )
		beam = (BeamAttributes *) SvIV((SV*) SvRV( ST(2) ));
	else{
		warn( "Teapot::Main::steer_() -- beam is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (Teapot *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Teapot::Main::steer_() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 120 "Main.xs"
	AV* ads  = (AV*) SvRV(rads);
	AV* dets = (AV*) SvRV(rdets);
	int yes = 1, i;
	PacVector<int> vads(1 + (int) av_len(ads)), vdets(1 + (int) av_len(dets));
	for(i= 0; i < vads.size(); i++) {
		vads[i] = (int) SvIV( *av_fetch(ads, (I32) i, (I32) yes));
	}
	for(i= 0; i < vdets.size(); i++) {
		vdets[i] = (int) SvIV( *av_fetch(dets, (I32) i, (I32) yes));
	};	
	THIS->steer(*orbit, *beam, vads, vdets, method, plane);
#line 564 "Main.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Teapot__Main_ftsteer_); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Teapot__Main_ftsteer_)
{
    dVAR; dXSARGS;
    if (items != 10)
       croak_xs_usage(cv,  "THIS, orbit, beam, rhads, rhdets, rvads, rvdets, maxdev, tw, method");
    {
	Position*	orbit;
	BeamAttributes*	beam;
	SV*	rhads = ST(3)
;
	SV*	rhdets = ST(4)
;
	SV*	rvads = ST(5)
;
	SV*	rvdets = ST(6)
;
	double	maxdev = (double)SvNV(ST(7))
;
	PacTwissData*	tw;
	int	method = (int)SvIV(ST(9))
;
	Teapot *	THIS;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		orbit = (Position *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Teapot::Main::ftsteer_() -- orbit is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) )
		beam = (BeamAttributes *) SvIV((SV*) SvRV( ST(2) ));
	else{
		warn( "Teapot::Main::ftsteer_() -- beam is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(8)) && (SvTYPE(SvRV(ST(8))) == SVt_PVMG) )
		tw = (PacTwissData *) SvIV((SV*) SvRV( ST(8) ));
	else{
		warn( "Teapot::Main::ftsteer_() -- tw is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (Teapot *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Teapot::Main::ftsteer_() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 144 "Main.xs"
	AV* hads  = (AV*) SvRV(rhads);
	AV* hdets = (AV*) SvRV(rhdets);
        AV* vads  = (AV*) SvRV(rvads);
	AV* vdets = (AV*) SvRV(rvdets);
	int yes = 1, i;
	PacVector<int> vhads(1 + (int) av_len(hads)), vhdets(1 + (int) av_len(hdets));
        PacVector<int> vvads(1 + (int) av_len(vads)), vvdets(1 + (int) av_len(vdets));
        for(i= 0; i < vhads.size(); i++) {
		vhads[i] = (int) SvIV( *av_fetch(hads, (I32) i, (I32) yes));

	}
	for(i= 0; i < vhdets.size(); i++) {
		vhdets[i] = (int) SvIV( *av_fetch(hdets, (I32) i, (I32) yes));

	};	
        for(i= 0; i < vvads.size(); i++) {
		vvads[i] = (int) SvIV( *av_fetch(vads, (I32) i, (I32) yes));

	}
	for(i= 0; i < vvdets.size(); i++) {
		vvdets[i] = (int) SvIV( *av_fetch(vdets, (I32) i, (I32) yes));

	};	
        THIS->ftsteer(*orbit, *beam, vhads, vhdets, vvads, vvdets, maxdev, *tw, method);
#line 650 "Main.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Teapot__Main_twissList); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Teapot__Main_twissList)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "THIS, tw, beam, orbit");
    {
	PacTwissData*	tw;
	BeamAttributes*	beam;
	Position *	orbit;
	Teapot *	THIS;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		tw = (PacTwissData *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Teapot::Main::twissList() -- tw is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) )
		beam = (BeamAttributes *) SvIV((SV*) SvRV( ST(2) ));
	else{
		warn( "Teapot::Main::twissList() -- beam is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(3)) && (SvTYPE(SvRV(ST(3))) == SVt_PVMG) )
		orbit = (Position *) SvIV((SV*) SvRV( ST(3) ));
	else{
		warn( "Teapot::Main::twissList() -- orbit is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (Teapot *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Teapot::Main::twissList() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 176 "Main.xs"
        THIS->twissList(*tw, *beam, *orbit);
#line 701 "Main.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Teapot__Main_twiss); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Teapot__Main_twiss)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "THIS, tw, beam, orbit");
    {
	PacTwissData*	tw;
	BeamAttributes*	beam;
	Position *	orbit;
	Teapot *	THIS;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		tw = (PacTwissData *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Teapot::Main::twiss() -- tw is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) )
		beam = (BeamAttributes *) SvIV((SV*) SvRV( ST(2) ));
	else{
		warn( "Teapot::Main::twiss() -- beam is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(3)) && (SvTYPE(SvRV(ST(3))) == SVt_PVMG) )
		orbit = (Position *) SvIV((SV*) SvRV( ST(3) ));
	else{
		warn( "Teapot::Main::twiss() -- orbit is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (Teapot *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Teapot::Main::twiss() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 186 "Main.xs"
	THIS->twiss(*tw, *beam, *orbit);
#line 752 "Main.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Teapot__Main_trackTwiss); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Teapot__Main_trackTwiss)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, tw, vtps");
    {
	PacTwissData*	tw;
	PacVTps*	vtps;
	Teapot *	THIS;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		tw = (PacTwissData *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Teapot::Main::trackTwiss() -- tw is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) )
		vtps = (PacVTps *) SvIV((SV*) SvRV( ST(2) ));
	else{
		warn( "Teapot::Main::trackTwiss() -- vtps is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (Teapot *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Teapot::Main::trackTwiss() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 194 "Main.xs"
	THIS->trackTwiss(*tw, *vtps);
#line 794 "Main.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Teapot__Main_tunethin_); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Teapot__Main_tunethin_)
{
    dVAR; dXSARGS;
    if (items != 11)
       croak_xs_usage(cv,  "THIS, beam, orbit, rb1f, rb1d, mux, muy, method, numtries, tolerance, stepsize");
    {
	BeamAttributes*	beam;
	Position *	orbit;
	SV*	rb1f = ST(3)
;
	SV*	rb1d = ST(4)
;
	double	mux = (double)SvNV(ST(5))
;
	double	muy = (double)SvNV(ST(6))
;
	char	method = (char)*SvPV_nolen(ST(7))
;
	int	numtries = (int)SvIV(ST(8))
;
	double	tolerance = (double)SvNV(ST(9))
;
	double	stepsize = (double)SvNV(ST(10))
;
	Teapot *	THIS;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		beam = (BeamAttributes *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Teapot::Main::tunethin_() -- beam is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) )
		orbit = (Position *) SvIV((SV*) SvRV( ST(2) ));
	else{
		warn( "Teapot::Main::tunethin_() -- orbit is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (Teapot *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Teapot::Main::tunethin_() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 209 "Main.xs"
	AV* b1f = (AV*) SvRV(rb1f);
	AV* b1d = (AV*) SvRV(rb1d);
	int yes = 1, i;
	PacVector<int> vb1f(1 + (int) av_len(b1f)), vb1d(1 + (int) av_len(b1d));
	for(i= 0; i < vb1f.size(); i++) {
		vb1f[i] = (int) SvIV( *av_fetch(b1f, (I32) i, (I32) yes));
	}
	for(i= 0; i < vb1d.size(); i++) {
		vb1d[i] = (int) SvIV( *av_fetch(b1d, (I32) i, (I32) yes));
	};	
	THIS->tunethin(*beam, *orbit, vb1f, vb1d, mux, muy, method, numtries, tolerance, stepsize);
#line 862 "Main.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Teapot__Main_eigenTwiss); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Teapot__Main_eigenTwiss)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, tw, map");
    {
	PacTwissData*	tw;
	PacVTps*	map;
	Teapot *	THIS;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		tw = (PacTwissData *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Teapot::Main::eigenTwiss() -- tw is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) )
		map = (PacVTps *) SvIV((SV*) SvRV( ST(2) ));
	else{
		warn( "Teapot::Main::eigenTwiss() -- map is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (Teapot *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Teapot::Main::eigenTwiss() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 226 "Main.xs"
	THIS->eigenTwiss(*tw, *map);
#line 904 "Main.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Teapot__Main_trackEigenTwiss); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Teapot__Main_trackEigenTwiss)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, tw, sector");
    {
	PacTwissData*	tw;
	PacVTps*	sector;
	Teapot *	THIS;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		tw = (PacTwissData *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Teapot::Main::trackEigenTwiss() -- tw is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) )
		sector = (PacVTps *) SvIV((SV*) SvRV( ST(2) ));
	else{
		warn( "Teapot::Main::trackEigenTwiss() -- sector is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (Teapot *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Teapot::Main::trackEigenTwiss() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 233 "Main.xs"
	THIS->trackEigenTwiss(*tw, *sector);
#line 946 "Main.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Teapot__Main_chrom); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Teapot__Main_chrom)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "THIS, tw, beam, orbit");
    {
	PacChromData*	tw;
	BeamAttributes*	beam;
	Position *	orbit;
	Teapot *	THIS;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		tw = (PacChromData *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Teapot::Main::chrom() -- tw is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) )
		beam = (BeamAttributes *) SvIV((SV*) SvRV( ST(2) ));
	else{
		warn( "Teapot::Main::chrom() -- beam is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(3)) && (SvTYPE(SvRV(ST(3))) == SVt_PVMG) )
		orbit = (Position *) SvIV((SV*) SvRV( ST(3) ));
	else{
		warn( "Teapot::Main::chrom() -- orbit is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (Teapot *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Teapot::Main::chrom() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 241 "Main.xs"
	THIS->chrom(*tw, *beam, *orbit);
#line 997 "Main.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Teapot__Main_chromfit_); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Teapot__Main_chromfit_)
{
    dVAR; dXSARGS;
    if (items != 11)
       croak_xs_usage(cv,  "THIS, beam, orbit, rb1f, rb1d, mux, muy, method, numtries, tolerance, stepsize");
    {
	BeamAttributes*	beam;
	Position *	orbit;
	SV*	rb1f = ST(3)
;
	SV*	rb1d = ST(4)
;
	double	mux = (double)SvNV(ST(5))
;
	double	muy = (double)SvNV(ST(6))
;
	char	method = (char)*SvPV_nolen(ST(7))
;
	int	numtries = (int)SvIV(ST(8))
;
	double	tolerance = (double)SvNV(ST(9))
;
	double	stepsize = (double)SvNV(ST(10))
;
	Teapot *	THIS;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		beam = (BeamAttributes *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Teapot::Main::chromfit_() -- beam is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) )
		orbit = (Position *) SvIV((SV*) SvRV( ST(2) ));
	else{
		warn( "Teapot::Main::chromfit_() -- orbit is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (Teapot *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Teapot::Main::chromfit_() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 256 "Main.xs"
	AV* b1f = (AV*) SvRV(rb1f);
	AV* b1d = (AV*) SvRV(rb1d);
	int yes = 1, i;
	PacVector<int> vb1f(1 + (int) av_len(b1f)), vb1d(1 + (int) av_len(b1d));
	for(i= 0; i < vb1f.size(); i++) {
		vb1f[i] = (int) SvIV( *av_fetch(b1f, (I32) i, (I32) yes));
	}
	for(i= 0; i < vb1d.size(); i++) {
		vb1d[i] = (int) SvIV( *av_fetch(b1d, (I32) i, (I32) yes));
	};	
	THIS->chromfit(*beam, *orbit, vb1f, vb1d, mux, muy, method, numtries, tolerance, stepsize);
#line 1065 "Main.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Teapot__Main_map); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Teapot__Main_map)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "THIS, vtps, beam, order");
    {
	PacVTps*	vtps;
	BeamAttributes*	beam;
	int	order = (int)SvIV(ST(3))
;
	Teapot *	THIS;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		vtps = (PacVTps *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Teapot::Main::map() -- vtps is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) )
		beam = (BeamAttributes *) SvIV((SV*) SvRV( ST(2) ));
	else{
		warn( "Teapot::Main::map() -- beam is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (Teapot *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Teapot::Main::map() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 274 "Main.xs"
	THIS->map(*vtps, *beam, order);
#line 1109 "Main.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Teapot__Main_trackMap); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Teapot__Main_trackMap)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "THIS, vtps, beam, i1, i2");
    {
	PacVTps*	vtps;
	BeamAttributes*	beam;
	int	i1 = (int)SvIV(ST(3))
;
	int	i2 = (int)SvIV(ST(4))
;
	Teapot *	THIS;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		vtps = (PacVTps *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Teapot::Main::trackMap() -- vtps is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) )
		beam = (BeamAttributes *) SvIV((SV*) SvRV( ST(2) ));
	else{
		warn( "Teapot::Main::trackMap() -- beam is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (Teapot *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Teapot::Main::trackMap() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 284 "Main.xs"
	THIS->trackMap(*vtps, *beam, i1, i2);
#line 1155 "Main.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Teapot__Main_transformOneTurnMap); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Teapot__Main_transformOneTurnMap)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, output, oneTurnMap");
    {
	PacVTps*	output;
	PacVTps*	oneTurnMap;
	Teapot *	THIS;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		output = (PacVTps *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Teapot::Main::transformOneTurnMap() -- output is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) )
		oneTurnMap = (PacVTps *) SvIV((SV*) SvRV( ST(2) ));
	else{
		warn( "Teapot::Main::transformOneTurnMap() -- oneTurnMap is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (Teapot *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Teapot::Main::transformOneTurnMap() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 291 "Main.xs"
	THIS->transformOneTurnMap(*output, *oneTurnMap);
#line 1197 "Main.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Teapot__Main_transformSectorMap); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Teapot__Main_transformSectorMap)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "THIS, output, oneTurnMap, sectorMap");
    {
	PacVTps*	output;
	PacVTps*	oneTurnMap;
	PacVTps*	sectorMap;
	Teapot *	THIS;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		output = (PacVTps *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Teapot::Main::transformSectorMap() -- output is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) )
		oneTurnMap = (PacVTps *) SvIV((SV*) SvRV( ST(2) ));
	else{
		warn( "Teapot::Main::transformSectorMap() -- oneTurnMap is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(3)) && (SvTYPE(SvRV(ST(3))) == SVt_PVMG) )
		sectorMap = (PacVTps *) SvIV((SV*) SvRV( ST(3) ));
	else{
		warn( "Teapot::Main::transformSectorMap() -- sectorMap is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (Teapot *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Teapot::Main::transformSectorMap() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 299 "Main.xs"
	THIS->transformSectorMap(*output, *oneTurnMap, *sectorMap);
#line 1248 "Main.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Teapot__Main_matrix); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Teapot__Main_matrix)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "THIS, vtps, beam, delta");
    {
	PacVTps*	vtps;
	BeamAttributes*	beam;
	Position*	delta;
	Teapot *	THIS;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		vtps = (PacVTps *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Teapot::Main::matrix() -- vtps is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) )
		beam = (BeamAttributes *) SvIV((SV*) SvRV( ST(2) ));
	else{
		warn( "Teapot::Main::matrix() -- beam is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(3)) && (SvTYPE(SvRV(ST(3))) == SVt_PVMG) )
		delta = (Position *) SvIV((SV*) SvRV( ST(3) ));
	else{
		warn( "Teapot::Main::matrix() -- delta is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (Teapot *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Teapot::Main::matrix() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 308 "Main.xs"
	THIS->matrix(*vtps, *beam, *delta);
#line 1299 "Main.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Teapot__Main_decouple_); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Teapot__Main_decouple_)
{
    dVAR; dXSARGS;
    if (items != 11)
       croak_xs_usage(cv,  "THIS, beam, orbit, ra11s, ra12s, ra13s, ra14s, rbfs, rbds, mux, muy");
    {
	BeamAttributes*	beam;
	Position*	orbit;
	SV*	ra11s = ST(3)
;
	SV*	ra12s = ST(4)
;
	SV*	ra13s = ST(5)
;
	SV*	ra14s = ST(6)
;
	SV*	rbfs = ST(7)
;
	SV*	rbds = ST(8)
;
	double	mux = (double)SvNV(ST(9))
;
	double	muy = (double)SvNV(ST(10))
;
	Teapot *	THIS;

	if(sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		beam = (BeamAttributes *) SvIV((SV*) SvRV( ST(1) ));
	else{
		warn( "Teapot::Main::decouple_() -- beam is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) )
		orbit = (Position *) SvIV((SV*) SvRV( ST(2) ));
	else{
		warn( "Teapot::Main::decouple_() -- orbit is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	if(sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (Teapot *) SvIV((SV*) SvRV( ST(0) ));
	else{
		warn( "Teapot::Main::decouple_() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 323 "Main.xs"
	AV* a11s  = (AV*) SvRV(ra11s);
	AV* a12s  = (AV*) SvRV(ra12s);
	AV* a13s = (AV*) SvRV(ra13s);
	AV* a14s = (AV*) SvRV(ra14s);
	AV* bfs   = (AV*) SvRV(rbfs);
	AV* bds   = (AV*) SvRV(rbds);
	int yes = 1, i;
	PacVector<int> va11s(1 + (int) av_len(a11s));
	for(i= 0; i < va11s.size(); i++) {
		va11s[i] = (int) SvIV( *av_fetch(a11s, (I32) i, (I32) yes));
	}
	PacVector<int> va12s(1 + (int) av_len(a12s));
	for(i= 0; i < va12s.size(); i++) {
		va12s[i] = (int) SvIV( *av_fetch(a12s, (I32) i, (I32) yes));
	}
	PacVector<int> va13s(1 + (int) av_len(a13s));
	for(i= 0; i < va13s.size(); i++) {
		va13s[i] = (int) SvIV( *av_fetch(a13s, (I32) i, (I32) yes));
	}
	PacVector<int> va14s(1 + (int) av_len(a14s));
	for(i= 0; i < va14s.size(); i++) {
		va14s[i] = (int) SvIV( *av_fetch(a14s, (I32) i, (I32) yes));
	}
	PacVector<int> vbfs(1 + (int) av_len(bfs));
	for(i= 0; i < vbfs.size(); i++) {
		vbfs[i] = (int) SvIV( *av_fetch(bfs, (I32) i, (I32) yes));
	}
	PacVector<int> vbds(1 + (int) av_len(bds));
	for(i= 0; i < vbds.size(); i++) {
		vbds[i] = (int) SvIV( *av_fetch(bds, (I32) i, (I32) yes));
	}
	THIS->decouple(*beam, *orbit, va11s, va12s, va13s, va14s, vbfs, vbds, mux, muy);
#line 1388 "Main.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Teapot__Main); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Teapot__Main)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

        (void)newXSproto_portable("Teapot::Main::new", XS_Teapot__Main_new, file, "$");
        (void)newXSproto_portable("Teapot::Main::use", XS_Teapot__Main_use, file, "$$");
        (void)newXSproto_portable("Teapot::Main::DESTROY", XS_Teapot__Main_DESTROY, file, "$");
        (void)newXSproto_portable("Teapot::Main::makethin", XS_Teapot__Main_makethin, file, "$");
        (void)newXSproto_portable("Teapot::Main::size", XS_Teapot__Main_size, file, "$");
        (void)newXSproto_portable("Teapot::Main::element", XS_Teapot__Main_element, file, "$$");
        (void)newXSproto_portable("Teapot::Main::track", XS_Teapot__Main_track, file, "$;@");
        (void)newXSproto_portable("Teapot::Main::survey", XS_Teapot__Main_survey, file, "$$$$");
        (void)newXSproto_portable("Teapot::Main::clorbit", XS_Teapot__Main_clorbit, file, "$$$");
        (void)newXSproto_portable("Teapot::Main::trackClorbit", XS_Teapot__Main_trackClorbit, file, "$$$$$");
        (void)newXSproto_portable("Teapot::Main::steer_", XS_Teapot__Main_steer_, file, "$$$$$$$");
        (void)newXSproto_portable("Teapot::Main::ftsteer_", XS_Teapot__Main_ftsteer_, file, "$$$$$$$$$$");
        (void)newXSproto_portable("Teapot::Main::twissList", XS_Teapot__Main_twissList, file, "$$$$");
        (void)newXSproto_portable("Teapot::Main::twiss", XS_Teapot__Main_twiss, file, "$$$$");
        (void)newXSproto_portable("Teapot::Main::trackTwiss", XS_Teapot__Main_trackTwiss, file, "$$$");
        (void)newXSproto_portable("Teapot::Main::tunethin_", XS_Teapot__Main_tunethin_, file, "$$$$$$$$$$$");
        (void)newXSproto_portable("Teapot::Main::eigenTwiss", XS_Teapot__Main_eigenTwiss, file, "$$$");
        (void)newXSproto_portable("Teapot::Main::trackEigenTwiss", XS_Teapot__Main_trackEigenTwiss, file, "$$$");
        (void)newXSproto_portable("Teapot::Main::chrom", XS_Teapot__Main_chrom, file, "$$$$");
        (void)newXSproto_portable("Teapot::Main::chromfit_", XS_Teapot__Main_chromfit_, file, "$$$$$$$$$$$");
        (void)newXSproto_portable("Teapot::Main::map", XS_Teapot__Main_map, file, "$$$$");
        (void)newXSproto_portable("Teapot::Main::trackMap", XS_Teapot__Main_trackMap, file, "$$$$$");
        (void)newXSproto_portable("Teapot::Main::transformOneTurnMap", XS_Teapot__Main_transformOneTurnMap, file, "$$$");
        (void)newXSproto_portable("Teapot::Main::transformSectorMap", XS_Teapot__Main_transformSectorMap, file, "$$$$");
        (void)newXSproto_portable("Teapot::Main::matrix", XS_Teapot__Main_matrix, file, "$$$$");
        (void)newXSproto_portable("Teapot::Main::decouple_", XS_Teapot__Main_decouple_, file, "$$$$$$$$$$$");
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

